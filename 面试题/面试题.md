面试题

###### Java基础

* 运算符：&:左右同1为1；|:左右有1就为1；~:类似!，1和0互换；^:讲究对称，左右同为0，不同为1；

* 基础类型字节数？
1字节：boolean，byte；2字节：char，short；4字节：int，float；8字节：long，double。1字节等于8位；

* Integer
int和Integer比较比的是值；2个new 出来的Integer对象肯定不相等；2个非new Integer如果在-128和127之间会相等，Java编译Integer i2 = 128时,被翻译成Integer i2 = Integer.valueOf(128)，而valueOf()会对-128到127之间进行缓存；

* String、StringBuffer、StringBuilder区别
String不可变对象，SBui速度快，SBuf是SBui加锁版本。SBui内部维护char数组，速度快开销小，String每次"+"都会创建一个临时对象，慢且内存开销大。

* 抽象类是否可以没有方法和属性？抽象类可以没有抽象方法和其他正常方法及属性，但有抽象方法的类必须是抽象类

* 父类的静态方法能否被子类重写？静态方法由类直接调用，与对象无关。子类重写父类静态方法不报错，仅仅是子类定义了和父类静态方法名和参数均相同的方法，2个方法分别属于子类父类。

* Serializable 和Parcelable 的区别
Serializable：Java的序列化方式，反射使用IO读写在硬盘上，序列化时创建许多临时对象，容易触发GC。速度慢，编写简单。
Parcelable：Android的方式，在内存中读写，将对象完整分解，而分解后的每一部分都是Intent所支持的数据类型。速度快，编写繁琐。

* 内部类、静态内部类、局部内部类和匿名内部类的理解
使用上静态内部类不依赖于外部类，直接通过类名操作静态内部类。内部类则是依附于外部类，需要外部类实例去生成内部类。
内部类默认持有外部类引用，可以无限制的访问外围类的所有成员属性和方法(包括private)、但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问、成员内部类中不能存在任何static的变量和方法、只有先创建了外围类才能够创建内部类
静态内部类与外部类没有任何关系，可以理解为减少包结构深度
内部类的重要作用在于为多重继承提供支持。如：用多个内部类继承多个外部类准备继承的类，外部类的相对应方法用new 内部类.methon()的形式去提供给外部，达到变相多继承。

* 多态
   * 动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法
必要条件：继承、重写、向上转型(父类引用指向子类对象)。
实现方式：实现接口或者继承父类进行方法重写、同一个类中进行方法重载
好处：可替换、可扩展、灵活。提高了代码的维护性(继承保证)、提高了代码的扩展性(由多态保证)
作用：消除类型之间的耦合关系。
多态分为两种：a. 编译时多态：方法的重载；b. 运行时多态：JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态。(多态主要指运行时多态)
子类在重写父类的方法时，方法的访问权限不能更低。
多态调用顺序优先级由高到低为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。①在声明类中查找，再查找超类 ②然后把参数向上转型执行①步骤。
重写是静态绑定,在编译期；重载是动态绑定，在运行期。
   * 你说说重写和重载区别，体现多态的例子。重写和重载前提是方法名必须相同。
重载：必须具有不同的参数列表、可以有不同的返回类型、可以有不同的访问修饰符、可以抛出不同的异常；
重写：参数列表必须与被重写的方法相同(否则是重载)、返回的类型必须与被重写方法的返回类型相同(否则编译失败)、访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default，private不能重写）、重写方法不能抛出新的检查异常或者比被重写方法更加宽泛的检查型异常(只能抛出相同异常或者其子类异常)。
   * 修饰符：public>protected>default>private。private当前对象有权限、default当前对象和同包有权限、protected当前对象、子类及同包下有权限、public全部开放权限

* String原理
    1. String str1 = new String("abc");    Stirng str2 = "abc";  两个语句都返回一个String对象的引用，但是jvm对两者的处理方式是不一样的。
    2. 第一种，jvm会马上在heap中创建一个String对象，然后将该对象的引用返回给用户。
    3. 第二种，jvm首先会在内部维护的String Pool中通过String的 equals 方法查找是对象池中是否存放有该String对象，如果有则返回已有的String对象给用户，不会在heap中重新创建一个新的String对象；如果对象池中没有该String对象，jvm则在heap中创建新的String对象，将其引用返回给用户，同时将该引用添加至String Pool中。
    4. 使用new创建对象时，jvm不会主动把该对象放到String Pool里面的，除非程序调用 String的intern方法。

* String为什么要设计成不可变的？
安全：防止被篡改。常量池：每次创建String都在堆内存中创建对象的话浪费内存。线程安全：多线程操作String时保证线程安全。HashCode：配合Map、Set使用时用到hashcode保证Hashcode不变才能正常使用容器。

* Java反射
在Java运行时环境中，可以知道任意一个类有哪些属性和方法。可以调用任意一个对象的所有方法。这种动态获取类的信息以及动态调用对象的方法的功能便是反射。
在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；

* 说说你对Java注解的理解
    * 注解：是一系列元数据，它提供数据用来解释程序代码。但是注解并非是所解释的代码本身的一部分，对于代码的运行效果没有直接影响。
    * 作用：- 编写代码时处理： 编译器可以利用注解来探测错误和警告信息 - 编译时处理： 可以用来利用注解信息来生成代码或其它处理。 - 运行时处理： 可以在程序运行的时候接受代码的提取
    * 元注解：是一种基本注解，但是它能够应用到其它的注解上面。有@Retention、@Documented、@Target、@Inherited、@Repeatable 5 种
        * @Retention：存活/生命周期。方法体RetentionPolicy value(){SOURCE源码保留编译丢弃,CLASS编译保留但不存在JVM中,RUNTIME存在JVM中且可通过AnnotatedElement获取}
        * @Documented：保存在javadoc中
        * @Target：标记位置/作用范围。方法体ElementType[] value(){FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ANNOTATION_TYPE标记注解,TYPE在类接口枚举上标记}
        * @Inherited:用于标记Class。子类没注解则继承父类注解。
        * @Repeatable：标记在注解A上，属性值为注解B，注解B的方法体为 注解A[] value() 。注解A在使用时可以被标记多次。
    * 属性：必须是 8 种基本数据类型外加类、接口、注解及它们的数组组成。
    * Java预置注解。@Deprecated、@Override、@SuppressWarnings。
    * 注解和反射配合。Class的isAnnotationPresent(判断有无注解)，getAnnotation/getAnnotations(获取注解)，得到注解实例，获取注解相应值等。

* 说一下泛型原理？
Java泛型是通过擦除实现的，类定义中的类型参数如T会被替换为Object，在程序运行过程中，不知道泛型的实际类型参数。好处为安全(编译期间便知道类型是否有问题)和可读性高(显式的明确知道某个类型)，extend A，上限，A的子类，上限是A；super A，下限，A的父类，下限是A。


###### Java集合类

* HashMap的原理？put和get过程
put：
首先求key的hashcode，处理后得到下标；
如果该下标没有Node，则直接存储key value到新Node；
如果有Node但不相等则以链表形式添加到后面；
如果链表长度等于8则转换成红黑树，如果长度低于6，则把树转回链表；
如该下标有Node且遍历整个链表或树时，hash和(key或equal)相等，则替换掉value；
如果容量超过0.75则扩容2倍后对HashMap重排
get：
求key对hashcode，得到下标；
找到下标后去查找链表或者树，对比hashcode和(key相等或equals相等)为true，则返回value；

* 减少碰撞
重写hashcode和equals方法尽量让其不相等；使用不可变类如String，Integer等。
String和Integer为什么适合？因为其final属性且重写了hashcode和equals方法。

* hash函数如何实现的
对hashcode值无符号右移>>>16位，得到的值与hashcode进行异或^，最后把异或的值和(N-1)做与&操作，得到下标。

* 为什么用红黑树不用二叉树或其他树？
因为二叉树在特殊情况下变成单链条结构，性能变慢，但红黑树是平衡二叉树，不会有这样的问题。

* 重新调整HashMap大小会出现什么问题？
多线程的问题。当HashMap调整大小时，会把链表次序颠倒过来存储，如果多个线程一起操作会造成死循环。

* entrySet和keySet哪个效率高？entrySet，因为它只遍历一次，keySet遍历2次。

* HashMap和HashTable区别？
HM无锁，HT有锁，HT效率低但安全；HM可以空key和value，HT均不能；HT有contains，HM有containsK和coontainsV；

* HashMap和TreeMap区别？
TM实现排序接口是排序好的，HM不是；HM效率高，因为使用hashcode随机访问，TM是排序后的，查找慢。

* HashMap和HashSet区别？
HM是key value，HS内部用HM把添加的值当作key存到HM中，与vaule无关。

* HashMap的value为空？使用可变的key，容易造成找不到value。

* WeakHashMap 是怎么工作的？使用弱引用作为 key。

* ConcurrentHashMap的实现原理？
ConcurrentHashMap不同于HT把整个HT加锁，而是针对单个桶加锁，默认16个元素支持16个锁，提高效率。
Collections.synchronizedMap()和Hashtable一样，都对整个map进行同步，而ConcurrentHashMap只对map中的所有桶加了锁。所以有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map其他桶执行操作。这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。ConcurrentHashMap必然是个HashMap，而Collections.synchronizedMap()可以接收任意Map实例，实现Map的同步。

* ArrayList和LinkedList的区别？
AL是在内存一片连续的空间，LL是链表的操作；AL读取快，LL要遍历慢，添加队尾AL和LL一样快，添加随机位置AL和LL一样慢，删除AL逐个移动慢LL快。

* Vector与ArrayList区别？Vector线程安全。Vector 默认扩容 2 倍，ArrayList 是 1.5。

* SparseArray和HashMap？
内部2个数组，int为key obj为value；存int快省去了转换成Integer的开销；速度快，存取用二分查找。

* 深拷贝和浅拷贝？
深拷贝是新对象和新对象属性的内存地址都不一样，浅拷贝还是指向同一个内存地址。

###### Java多线程

* 

###### Http网络

* 7层模型？七层模型自下而上分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中低四层完成数据传输，高三层面向用户。
* TCP、UDP区别？应用场景？拥塞控制原理，视频传输为什么用UDP，UDP丢包会产生什么问题？
* TCP三次握手四次挥手过程？为什么有三次握手，不是四次，或者两次？TCP是哪一层协议？OSI七层模型？
* https的对称加密和非对称加密？Http头部有哪些，用过哪些？Http和Https区别，没有CA证书可以使用Https访问吗？
* 七层模型，HTTP 内容，常见响应码，缓存相关，TCP， 三次握手、四次挥手，Socket 的使用
http://blog.csdn.net/u011240877/article/details/72860483

###### 面试题常见
常见知识点：Java：多线程知识（锁、线程池）、内存模型、HashMap等；Android：线程间通信、多进程、View绘制、事件分发；算法：链表翻转、快速排序、二分查找、栈相关、int翻转、数组合并、LRUCache等，其他：MVP、单例、HTTPS等等。

* 给两个栈模拟队列？快排？二分？

* Handler的工作原理？除主线程之外其他的都要调用Looper.perpare()？Looper，Message和MessageQueue关系？MessageQueue中没有Message会怎么处理？子线程能不能创建Handler？
* Handler, HandlerThread, IntentService, AsyncTask
https://blog.csdn.net/u011240877/article/details/72892321
https://blog.csdn.net/u011240877/article/details/72905631
http://blog.csdn.net/u011240877/article/details/72972610

* Act启动模式？Activity界面绘制的过程？
https://blog.csdn.net/u011240877/article/details/71076342
http://blog.csdn.net/u011240877/article/details/71305797
http://blog.csdn.net/u011240877/article/details/72654743

* Service的生命周期？和IntentService有什么区别？与service通信是否会阻塞当前线程?如果是耗时方法，为什么会阻塞？startService和bindSerivce对service生命周期的影响？aidl传递Bitmap需要注意的事项

* 广播onReceive方法调用线程？静态广播接收流程？动态广播接收流程？动态广播能不能重复注册？

* onSavedInstanceState？灭屏会不会触发onSavedInstance？onRestoreInstanceState和onSavedInstanceState是否成对出现？

* 自定义View流程？invalidate、postInvalidate、requestLayout的区别？View的位置参数有哪些，left，x，translationX的含义以及三者的关系？View的性能优化？页面卡顿的原因？

* 事件分发和例子？Touch事件的分发流程？

* 常用动画

* ANR是什么？

* 线程进程

* 大图加载的缓存？Bitmap优化 ？

* 多进程通信方式

* 内存泄漏场景，排查手段。

* 数据库手写SQL？排斥，怎么批量提交SQL，添加事务。

* 图片库Glide的分析？Glide的优势？它是如何绑定生命周期的？

* 序列化前后对象有何区别

* rxjava的线程切换原理

* ListView如何优化，listView和RecyclerView的区别，二者的缓存逻辑

* App的启动流程

* MVC到MVP的架构重构流程

* LeakCanary原理？EventBus原理？Glide原理？Lrucache原理？
重要的是理解为什么要有这个框架，解决的问题，如何解决的
http://blog.csdn.net/u011240877/article/details/74599216

* 内存泄露的分析流程？
http://hukai.me/blog/archives/

* 进程间通信方式，Binder原理s


* 垃圾回收原理及回收策略？Java中的强、软、弱、虚引用？GC roots是什么？Handler造成内存泄漏的整个引用链？

* AysncTask？各个函数分别在什么线程回调？

* 单例设计模式

* 类的加载机制？双亲委派模型？为什么用双亲委派模型？

* App启动流程优化

* 组件化开发流程，ARouter路由协议的原理分析？

* Synchronize关键字的作用范围，volatile关键字的作用？乐观锁与悲观锁？读写锁的应用？

* OkHttp

* Android中的动画及区别

* ThreadLocal原理

* 内存优化有哪几种方式？布局优化有哪几种方式？

* https://xiaozhuanlan.com/topic/1570489362

* https://github.com/francistao/LearningNotes

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 
