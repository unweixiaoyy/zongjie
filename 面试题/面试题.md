面试题

###### Java基础

* 运算符：&:左右同1为1；|:左右有1就为1；~:类似!，1和0互换；^:讲究对称，左右同为0，不同为1；

* 基础类型字节数？
1字节：boolean，byte；2字节：char，short；4字节：int，float；8字节：long，double。1字节等于8位；

* Integer
int和Integer比较比的是值；2个new 出来的Integer对象肯定不相等；2个非new Integer如果在-128和127之间会相等，Java编译Integer i2 = 128时,被翻译成Integer i2 = Integer.valueOf(128)，而valueOf()会对-128到127之间进行缓存；

* String、StringBuffer、StringBuilder区别
String不可变对象，SBui速度快，SBuf是SBui加锁版本。SBui内部维护char数组，速度快开销小，String每次"+"都会创建一个临时对象，慢且内存开销大。

* 抽象类是否可以没有方法和属性？抽象类可以没有抽象方法和其他正常方法及属性，但有抽象方法的类必须是抽象类

* 父类的静态方法能否被子类重写？静态方法由类直接调用，与对象无关。子类重写父类静态方法不报错，仅仅是子类定义了和父类静态方法名和参数均相同的方法，2个方法分别属于子类父类。

* Serializable 和Parcelable 的区别
Serializable：Java的序列化方式，反射使用IO读写在硬盘上，序列化时创建许多临时对象，容易触发GC。速度慢，编写简单。
Parcelable：Android的方式，在内存中读写，将对象完整分解，而分解后的每一部分都是Intent所支持的数据类型。速度快，编写繁琐。

* 内部类、静态内部类、局部内部类和匿名内部类的理解
使用上静态内部类不依赖于外部类，直接通过类名操作静态内部类。内部类则是依附于外部类，需要外部类实例去生成内部类。
内部类默认持有外部类引用，可以无限制的访问外围类的所有成员属性和方法(包括private)、但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问、成员内部类中不能存在任何static的变量和方法、只有先创建了外围类才能够创建内部类
静态内部类与外部类没有任何关系，可以理解为减少包结构深度
内部类的重要作用在于为多重继承提供支持。如：用多个内部类继承多个外部类准备继承的类，外部类的相对应方法用new 内部类.methon()的形式去提供给外部，达到变相多继承。

* 多态
   * 动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法
必要条件：继承、重写、向上转型(父类引用指向子类对象)。
实现方式：实现接口或者继承父类进行方法重写、同一个类中进行方法重载
好处：可替换、可扩展、灵活。提高了代码的维护性(继承保证)、提高了代码的扩展性(由多态保证)
作用：消除类型之间的耦合关系。
多态分为两种：a. 编译时多态：方法的重载；b. 运行时多态：JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态。(多态主要指运行时多态)
子类在重写父类的方法时，方法的访问权限不能更低。
多态调用顺序优先级由高到低为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。①在声明类中查找，再查找超类 ②然后把参数向上转型执行①步骤。
重写是静态绑定,在编译期；重载是动态绑定，在运行期。
   * 你说说重写和重载区别，体现多态的例子。重写和重载前提是方法名必须相同。
重载：必须具有不同的参数列表、可以有不同的返回类型、可以有不同的访问修饰符、可以抛出不同的异常；
重写：参数列表必须与被重写的方法相同(否则是重载)、返回的类型必须与被重写方法的返回类型相同(否则编译失败)、访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default，private不能重写）、重写方法不能抛出新的检查异常或者比被重写方法更加宽泛的检查型异常(只能抛出相同异常或者其子类异常)。
   * 修饰符：public>protected>default>private。private当前对象有权限、default当前对象和同包有权限、protected当前对象、子类及同包下有权限、public全部开放权限

* String原理
    1. String str1 = new String("abc");    Stirng str2 = "abc";  两个语句都返回一个String对象的引用，但是jvm对两者的处理方式是不一样的。
    2. 第一种，jvm会马上在heap中创建一个String对象，然后将该对象的引用返回给用户。
    3. 第二种，jvm首先会在内部维护的String Pool中通过String的 equals 方法查找是对象池中是否存放有该String对象，如果有则返回已有的String对象给用户，不会在heap中重新创建一个新的String对象；如果对象池中没有该String对象，jvm则在heap中创建新的String对象，将其引用返回给用户，同时将该引用添加至String Pool中。
    4. 使用new创建对象时，jvm不会主动把该对象放到String Pool里面的，除非程序调用 String的intern方法。

* String为什么要设计成不可变的？
安全：防止被篡改。常量池：每次创建String都在堆内存中创建对象的话浪费内存。线程安全：多线程操作String时保证线程安全。HashCode：配合Map、Set使用时用到hashcode保证Hashcode不变才能正常使用容器。

* Java反射
在Java运行时环境中，可以知道任意一个类有哪些属性和方法。可以调用任意一个对象的所有方法。这种动态获取类的信息以及动态调用对象的方法的功能便是反射。
在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；

* 说说你对Java注解的理解
    * 注解：是一系列元数据，它提供数据用来解释程序代码。但是注解并非是所解释的代码本身的一部分，对于代码的运行效果没有直接影响。
    * 作用：- 编写代码时处理： 编译器可以利用注解来探测错误和警告信息 - 编译时处理： 可以用来利用注解信息来生成代码或其它处理。 - 运行时处理： 可以在程序运行的时候接受代码的提取
    * 元注解：是一种基本注解，但是它能够应用到其它的注解上面。有@Retention、@Documented、@Target、@Inherited、@Repeatable 5 种
        * @Retention：存活/生命周期。方法体RetentionPolicy value(){SOURCE源码保留编译丢弃,CLASS编译保留但不存在JVM中,RUNTIME存在JVM中且可通过AnnotatedElement获取}
        * @Documented：保存在javadoc中
        * @Target：标记位置/作用范围。方法体ElementType[] value(){FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ANNOTATION_TYPE标记注解,TYPE在类接口枚举上标记}
        * @Inherited:用于标记Class。子类没注解则继承父类注解。
        * @Repeatable：标记在注解A上，属性值为注解B，注解B的方法体为 注解A[] value() 。注解A在使用时可以被标记多次。
    * 属性：必须是 8 种基本数据类型外加类、接口、注解及它们的数组组成。
    * Java预置注解。@Deprecated、@Override、@SuppressWarnings。
    * 注解和反射配合。Class的isAnnotationPresent(判断有无注解)，getAnnotation/getAnnotations(获取注解)，得到注解实例，获取注解相应值等。

* 说一下泛型原理？
Java泛型是通过擦除实现的，类定义中的类型参数如T会被替换为Object，在程序运行过程中，不知道泛型的实际类型参数。好处为安全(编译期间便知道类型是否有问题)和可读性高(显式的明确知道某个类型)，extend A，上限，A的子类，上限是A；super A，下限，A的父类，下限是A。


###### Java集合类

* HashMap的原理？put和get过程
put：
首先求key的hashcode，处理后得到下标；
如果该下标没有Node，则直接存储key value到新Node；
如果有Node但不相等则以链表形式添加到后面；
如果链表长度等于8则转换成红黑树，如果长度低于6，则把树转回链表；
如该下标有Node且遍历整个链表或树时，hash和(key或equal)相等，则替换掉value；
如果容量超过0.75则扩容2倍后对HashMap重排
get：
求key对hashcode，得到下标；
找到下标后去查找链表或者树，对比hashcode和(key相等或equals相等)为true，则返回value；

* 减少碰撞
重写hashcode和equals方法尽量让其不相等；使用不可变类如String，Integer等。
String和Integer为什么适合？因为其final属性且重写了hashcode和equals方法。

* hash函数如何实现的
对hashcode值无符号右移>>>16位，得到的值与hashcode进行异或^，最后把异或的值和(N-1)做与&操作，得到下标。

* 为什么用红黑树不用二叉树或其他树？
因为二叉树在特殊情况下变成单链条结构，性能变慢，但红黑树是平衡二叉树，不会有这样的问题。

* 重新调整HashMap大小会出现什么问题？
多线程的问题。当HashMap调整大小时，会把链表次序颠倒过来存储，如果多个线程一起操作会造成死循环。

* entrySet和keySet哪个效率高？entrySet，因为它只遍历一次，keySet遍历2次。

* HashMap和HashTable区别？
HM无锁，HT有锁，HT效率低但安全；HM可以空key和value，HT均不能；HT有contains，HM有containsK和coontainsV；

* HashMap和TreeMap区别？
TM实现排序接口是排序好的，HM不是；HM效率高，因为使用hashcode随机访问，TM是排序后的，查找慢。

* HashMap和HashSet区别？
HM是key value，HS内部用HM把添加的值当作key存到HM中，与vaule无关。

* HashMap的value为空？使用可变的key，容易造成找不到value。

* WeakHashMap 是怎么工作的？使用弱引用作为 key。

* ConcurrentHashMap的实现原理？
ConcurrentHashMap不同于HT把整个HT加锁，而是针对单个桶加锁，默认16个元素支持16个锁，提高效率。
Collections.synchronizedMap()和Hashtable一样，都对整个map进行同步，而ConcurrentHashMap只对map中的所有桶加了锁。所以有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map其他桶执行操作。这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。ConcurrentHashMap必然是个HashMap，而Collections.synchronizedMap()可以接收任意Map实例，实现Map的同步。

* ArrayList和LinkedList的区别？
AL是在内存一片连续的空间，LL是链表的操作；AL读取快，LL要遍历慢，添加队尾AL和LL一样快，添加随机位置AL和LL一样慢，删除AL逐个移动慢LL快。

* Vector与ArrayList区别？Vector线程安全。Vector 默认扩容 2 倍，ArrayList 是 1.5。

* SparseArray和HashMap？
内部2个数组，int为key obj为value；存int快省去了转换成Integer的开销；速度快，存取用二分查找。

* 深拷贝和浅拷贝？
深拷贝是新对象和新对象属性的内存地址都不一样，浅拷贝还是指向同一个内存地址。

###### Java多线程

* 

###### Http网络

* OSI模型和TCP/IP模型？
OSI从下往上，物理层、数据链路层、网络层、传输层、会话，表示，应用层；TCP/IP从下往上，链路层、网络层、传输层、应用层。其中会话表示应用3层对应于应用层，物理和数据链路层对应链路层。TCP／UDP在传输层，IP在网络层，Socket在TCP/UDP基础上做用于传输层和应用层，Http/FTP在应用层。

* TCP和UDP区别？TCP的3次握手4次挥手？UDP使用场景？为什么是3次挥手和4次握手？
TCP面向连接，双方可以发送数据(双向通信)，数据有序性，超时重传；UPD效率高速度快，无法保证消息准确率，它不建立连接也不按照顺序发送，适用于IP电话，网络视频等。
TCP的3次握手保障服务器建立连接。1:C端先发送SYN=1和随机seq=J到S端，C端进入SEND状态，2:S端收到SYN后，确认C端SYN即ACK=1和seq=J+1，再发送给C端SYC=1和seq=K，即SYN和ACK，S端进入Receiver状态，3:当C端收到S端SYN+ACK后，确认S端发送ACK=1和seq=K+1，C端和S端均进入连接状态，C端connect返回，S端accept返回。
为什么握手不是2次，如果是2次，S端不能确认C端是否收到S端的ACK反馈，如果C端没有收到超时了，要进行重发。后续的通信建立在S端和C端通信均被确认基础上。
TCP端4次挥手保障断开连接。1:C端向S端发送FIN=1和seq=U，C端等待发送关闭状态，2:S端收到确认C端ACK，关闭接受通道，向C端发送ACK=1和seq=U+1，C端收到后S端ACK后发送状态关闭，3:然后S端再向C端发送S端停止发送的FIN，S端发送FIN=1和seq=W并带着刚才的ACK，即FIN=1和seq=W加上ACK=1和seq=U+1，4:C端收到S端FIN后确认ACK，C端发送给S端ACK，即ACK=1，seq=W+1。
4次挥手为什么客户端要等待2MSL(最大等待时间)？
在第3步S端发给C端FIN信号后，C端要发给S端一个ACK信号，因为C端不确认S端是否收到ACK信号，需要等待2MSL时间确认这个事情。如果S端未收到C端ACK会再次向C端发送FIN信号的，保证继续关闭；如果S端收到C端ACK则不会有后续操作，C端等待2MSL后知道S端收到了ACK信号，则关闭。

* Sockek使用？
S端ServiceSocket，连接端口ip，调用accept接受C端请求；C端构造Socket，调用connect连接。心跳包则是定时任务向S端发送数据。
http://blog.csdn.net/u011240877/article/details/72860483

* Http和Https区别？https的对称加密和非对称加密？
请求头不同，Http不安全Https安全，Http端口80 Https端口443，Http不加密Https对传输的数据加密，Http无需证书Https需要证书。
Http快于Https，Https安全于Http。
对称加密：双方用同一个密钥，速度快，DES/AES，相对不安全；非对称加密：公钥和私钥，公钥可以发给任何人，使用公钥加密，私钥安全的保存在服务器，用来解密，这个过程比较慢。通常的办法是用非对称加密获取对称加密的私钥，再用这个私钥进行后面的通信操作。这个证书其实就包含了公钥。

* Http常用头部？accept、content-xxx、user-agent、cache-control。User-Agent: Mozilla/5.0..、Accept: application/json,application/xml、Accept-Encoding: gzip、Connection: keep-alive、Content-Length：25、Range：1、Cache-Control：no-cache
* Http常见响应码？200:返回正常；30x:1永久2临时重定向；400语法错误 403请求被服务器拒绝 404找不到资源；500服务器执行请求时发生错误 503服务器不可用。



###### 面试题常见
常见知识点：Java：多线程知识（锁、线程池）、内存模型、HashMap等；Android：线程间通信、多进程、View绘制、事件分发；算法：链表翻转、快速排序、二分查找、栈相关、int翻转、数组合并、LRUCache等，其他：MVP、单例、HTTPS等等。


* Handler的工作原理？Looper，Message和MessageQueue关系？
ActivityThread.main()，开启主线程Loop，先后调用Loop.prepareMainLoop和Loop.loop。
主线程Loop构造方法：1，构造MessageQueue对象(quitAllowed为false)，2:获取当前线程(主线程)。
prepareMainLoop：构造Loop对象(quitAllowed为false)并调用TL.set(Loop)把它绑定到主线程的ThreadLocal中,TL.set()又把当前的TL绑定到Thread的ThreadLocalMap中。只能调用一次。
loop：开启消息循环，等待Handler发送消息到Loop。
Loop.loop()：调用myLoop()获取当前线程的ThreadLocal设置的Loop对象，获取Loop中的MessageQueue对象，然后for(;;)无限循环调用MQ.next()取消息读消息，如果有消息则取出Message，调用Message.target.dispatchMessage(msg)分发消息，其中Message.target就是Handler。如果没有MQ没有Message，则会阻塞在MQ.next()中的nativePollOnce()方法。
Message.target何时赋值？
Handler在postRunnable或sendMessgae时，最终调用MQ.enqueueMessage时把this(Handler)传给Message.target的。或者是构造Message时传入了Handler的话也直接把Handler复制给了target。
主线程可以直接使用Handler？
因为在ActivithThread.main()就已经调用了Loop.prepareMainLoop()了。在非主线程中使用Handler需要先调用Loop.prepareMainLoop()。
Handle.dispatchMessage()处理消息流程:1，postRunnable(Runnable)，把Runnable传给Message.callback；2，构造Handler时候传入的Callback，赋值给Handler的Callback变量；3，覆写Handler的handleMessage()方法。流程是优先处理1，再处理2，最后3.

主线程的死循环一直运行特别消耗CPU资源？ 主线程的`MessageQueue`没有消息时，便阻塞在`Loop`的`MessageQueue.next()`中的`nativePollOnce()`里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。
退出Loop.loop循环？调用Loop.quit()。
为什么调用Loop.loop()前要先调用Loop.prapare()？为什么构造Handler前必须要调用Loop.prapare()？
因为loop()方法先调用myLoop()检查当前线程的ThreadLocal中是否绑定了Loop对象，不然异常！
Message为什么要绑定Handler？
enqueueMessage中判断如果msg.target(Handler)为空，异常！
Handler涉及到的内存泄漏？
非静态内部类持有外部引用，当Act销毁可能Handler还有任务未处理完造成一定程度的泄漏。在Activity销毁时移除Handler的消息；使用静态内部类病缓存Activity弱引用。
子线程更新Toast、Dialog？没问题，调用它们的shou()方法前先调用Loop.prepare()和Loop.loop()。

* HandlerThread, IntentService, AsyncTask？
HandlerThread：是一个包含Loop的Thread，在run方法中包含了Loop.prepare和Loop.loop，可以直接构造Handler省去Loop的麻烦，或者通过getThreadHandler()获取一个Handler。run方法未执行则没有Loop。
IntentService：

https://blog.csdn.net/u011240877/article/details/72905631
http://blog.csdn.net/u011240877/article/details/72972610




* Act启动模式？Activity界面绘制的过程？
https://blog.csdn.net/u011240877/article/details/71076342
http://blog.csdn.net/u011240877/article/details/71305797
http://blog.csdn.net/u011240877/article/details/72654743

* Service的生命周期？和IntentService有什么区别？与service通信是否会阻塞当前线程?如果是耗时方法，为什么会阻塞？startService和bindSerivce对service生命周期的影响？aidl传递Bitmap需要注意的事项

* 广播onReceive方法调用线程？静态广播接收流程？动态广播接收流程？动态广播能不能重复注册？

* onSavedInstanceState？灭屏会不会触发onSavedInstance？onRestoreInstanceState和onSavedInstanceState是否成对出现？

* 自定义View流程？invalidate、postInvalidate、requestLayout的区别？View的位置参数有哪些，left，x，translationX的含义以及三者的关系？View的性能优化？页面卡顿的原因？

* 事件分发和例子？Touch事件的分发流程？

* 常用动画

* ANR是什么？

* 线程进程

* 大图加载的缓存？Bitmap优化 ？

* 多进程通信方式

* 内存泄漏场景，排查手段。

* 数据库手写SQL？排斥，怎么批量提交SQL，添加事务。

* 图片库Glide的分析？Glide的优势？它是如何绑定生命周期的？

* 序列化前后对象有何区别

* rxjava的线程切换原理

* ListView如何优化，listView和RecyclerView的区别，二者的缓存逻辑

* App的启动流程

* MVC到MVP的架构重构流程

* 给两个栈模拟队列？快排？二分？

* LeakCanary原理？EventBus原理？Glide原理？Lrucache原理？
重要的是理解为什么要有这个框架，解决的问题，如何解决的
http://blog.csdn.net/u011240877/article/details/74599216

* 内存泄露的分析流程？
http://hukai.me/blog/archives/

* 进程间通信方式，Binder原理s


* 垃圾回收原理及回收策略？Java中的强、软、弱、虚引用？GC roots是什么？Handler造成内存泄漏的整个引用链？

* AysncTask？各个函数分别在什么线程回调？

* 单例设计模式

* 类的加载机制？双亲委派模型？为什么用双亲委派模型？

* App启动流程优化

* 组件化开发流程，ARouter路由协议的原理分析？

* Synchronize关键字的作用范围，volatile关键字的作用？乐观锁与悲观锁？读写锁的应用？

* OkHttp

* Android中的动画及区别

* ThreadLocal原理

* 内存优化有哪几种方式？布局优化有哪几种方式？

* https://xiaozhuanlan.com/topic/1570489362

* https://github.com/francistao/LearningNotes

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 
