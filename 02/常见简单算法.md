### 常见算法

#### 冒泡

```java
    public void maopaoSort(int[] data){
        for(int i=0;i<data.length;i++){
            for(int j=0;i<data.length-1-i;j++){
                if(data[j]>data[j+1]){
                    int temp = data[j];
                    data[j]=data[j+1];
                    data[j+1]=temp;
                }
            }
        }
    }
```

#### 快排

```java
    public void qsort(int[] data,int left,int right){
        if(left<right){
            int middle = getMiddle(data,left,right);
            qsort(data,left,middle-1);
            qsort(data,middle+1,right);
        }
    }
    public int getMiddle(int[] data,int left,int right){
        int temp = data[left];
        while(left<right){
            while(left<right&&data[right]>temp){
                right--;
            }
            swap(data,left,right);
            while(left<right&&data[left]<temp){
                left++
            }
            swap(data,left,right);
        }
        data[left]=temp;
        return left
    }
    public void swap(int[] data,int left,int right){
        int temp = data[left];
        data[left]=data[right];
        data[right]=temp;
    }
```

#### 二分查找法

```java
    public int search(int[] data,int value){
        int left=0;int right=data.length-1;
        while(left<=right){
            int middle = (left+right)/2;
            if(data[middle]==value){
                return middle;
            }else if(data[middle]>value){
                right=middle-1
            }else{
                left=middle+1;
            }
        }
    }
```

#### 斐波那契

递归
```java
    public void fbnq(int number){
        if(numbel<=0){
            return 0;
        }
        if(numbel==1){
            return 1;
        }
        return fbnq(n-1)+fbnq(n-2);
    }
```
遍历
```java
    public void fbnq(int num){
        if(numbel==0){
            return 0;
        }
        if(numbel==1){
            return 1;
        }
        int fbnqOne=0;
        int fbnqTwo=1;
        int value=0;
        for(int i=2;i<=num;i++){
            value=fbnqOne+fbnqTwo;
            fbnqOne=fbnqTwo;
            fbnqTwo=value;
        }
        return value;
    }
```

#### 二进制中1的个数

一个数字转换成2进制，返回1的数量：

```java
N           = 1 0 0 0 1 1 0 1 0 0
N-1         = 1 0 0 0 1 1 0 0 1 1
        N & (N-1)

N & (N-1)   = 1 0 0 0 1 1 0 0 0 0
```
根据 & 的特性，有如下解法。通常数字N-1和N本身做 & 操作是一种固定的算法
```java
    public int num(int n){
        int count=0;
        while(n>0){
            count++;
            n=n&(n-1);
        }
        return count;
    }
```

#### 用双栈模拟队列，用双队列模拟栈

```java
    解题思路要知道栈和队列的区别。通常是对入栈出栈、入队出队均折腾2遍即可。
```

#### 找出数组中出现超过一半的数字

数组中有一个数字超过一半，找出来，如：1，2，3，2，2，2，5，4，2
```java
    public int getNum(int[] data){
        if(data==null || data.length<=0) return -1;
        int result=data[0];
        int times=1;
        for(int i=1;i<data.length;i++){
            if(times==0){
                result=data[i];
                times=1;
            }else if(data[i]==result){
                times++;
            }else{
                times--;
            }
        }
        return result;
    }
```

#### 给一组字符,将字符从小到大排列

如"873ABCdekuqp"，按照大小排列
```java
    public void sortChars(char[] c){
        //Todo
    }
```

#### 猴子偷桃问题

一个猴子发现一堆桃子。第一天吃掉一个并拿走一半，回到家告诉第二个猴子。第二天第二个猴子吃掉一个并拿走了一半，回到家告诉第三个猴子。第三个猴子吃掉一个并拿走了一半。以此类推第10天，第10个猴子来到时发现还剩1个桃子。求第一天有多少个桃子。（优先递归程序）
```java
    //非递归
    public static int total(int day){
        int total=1;
        for(int i=day-1;i>0;i++){
            total = 2*total+1;
        }
        return total;   
    }
    //递归
    public static int total(int day) {
        if (day == 5) {
            return 1;
        }
        return 2 * (total(day + 1)) + 1;
    }
    //其中，如果是先先吃一个再拿走一半是 2*n+1，如果是先拿走一半再吃一个是 2(n+1)。
```


#### 

```java

```

#### 

```java

```

#### 

```java

```


